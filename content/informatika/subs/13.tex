\subsection{Öröklődés, sokalakúság, egységbe zárás, adatrejtés, kompozíció, aggregáció, többszörös öröklődés}

\noindent \textbf{Öröklődés:}
\begin{itemize}
    \item egy osztály felhasználható arra, hogy egy új, leszármazott osztályt hozzunk létre belőle
    \item hierarchia alakítható ki
    \item leszármazottban benne van az ősosztály összes adattagja és metódusa
    \item plusz adattagokkal és metódusokkal bővíthető
    \item adattagot, metódust törölni nem lehet
    \item ősben lévő kód újrahasznosul, nem kell újra megírni
    \item az ős változtatása benne lesz a leszármazottban is
    \item a meglévő kód bővíthető és változtatható is
    \item protected tagok: maradjon meg az adatrejtés elve, de a leszármazottak el tudják érni az ős adatait
    \item öröklődnek:
    \begin{itemize}
        \item metódusok, adattagok, operátorok
    \end{itemize}
    \item nem öröklődnek:
    \begin{itemize}
        \item konstruktorok
        \item destruktorok
        \item barát függvények
        \item túlterhelt = operátor
    \end{itemize}
\end{itemize}

\noindent \textbf{Sokalakúság:}
\begin{itemize}
    \item az örökléssel létrehozott osztály máshogy viselkedhet, mint az ősosztály
    \item megvalósítás: ugyanolyan nevű és paraméterű metódust tartalmaz, a törzsében más utasításokkal
\end{itemize}

\noindent \textbf{Egységbe zárás:}
\begin{itemize}
    \item objektum: az adatok (változók) és az azokon dolgozó programrészletek (függvények) egy helyen szerepeljenek
    \item c++ -ban struct kibővítve függvényekkel $\rightarrow$ class (osztály)
    \item az osztály tartalmaz
    \begin{itemize}
        \item adattagokat (tulajdonságok)
        \item tagfüggvényeket (metódus)
        \begin{itemize}
            \item belső, külső kifejtés (külsőnél hatókör operátor -- ,,::")
        \end{itemize}
    \end{itemize}
    \item tagfüggvény a this$\rightarrow$ pointeren keresztül éri el a példány adatait
\end{itemize}

\noindent \textbf{Adatrejtés:}
\begin{itemize}
    \item probléma: a kódban lévő változók szabadon változtathatóak értékadással, hibás tartalom előfordulhat
    \item megoldás: adatrejtés
    \item az osztály tagjait csak az osztály tagfüggvényei érik el
\end{itemize}

% [PLACEHOLDER FOR DATA HIDING DIAGRAM]

\begin{itemize}
    \item \textbf{módosítók (három féle elérés módosító):}
    \begin{itemize}
        \item private: csak az osztály tagfüggvényei érik el
        \item public: a külvilág is eléri (adatrejtés sérült)
        \item protected: csak az osztály és annak leszármazottjai érik el
    \end{itemize}
    \item a módosító addig érvényes, míg egy másik felül nem írja
    \item class esetén a private az előre bekapcsolt
    \item struct esetén a public
    \item szokásos metódusok: getter, setter
    \begin{itemize}
        \item csak így hívjuk őket, konvenció
        \item set beállít, get kiolvas
    \end{itemize}
\end{itemize}

\noindent \textbf{Kompozíció:}
\begin{itemize}
    \item ha egy osztályban statikus adattagként egy másik osztály szerepel
    \item a másik osztály példánya önállóan nem létezik, csak az első osztály példányában van
\begin{minted}{cpp}
struct p2d // nem kell public:
{
    double x, y;
};
struct p3d_komp
{
    p2d p2; // kompozició: statikus adattagja van
    double z; // plusz adattag.
};
\end{minted}
    \item példányosítás és használat:
\begin{minted}{cpp}
p3d_komp p3k;
p3k.p2.x = 0;
p3k.p2.y = 1;
p3k.z = 2;
\end{minted}
    \item az x és y adattagok előtt kell a beépített osztály neve (p2)
    \item a beépített osztályból nem kell önálló példány
\end{itemize}

\noindent \textbf{Aggregáció:}
\begin{itemize}
    \item ha egy osztályban külső adattagként (pointerrel, vagy referenciával) másik osztályra hivatkozás szerepel
    \item a másik osztály példányának önállóan léteznie kell, csak akkor tudunk rá mutató referenciát/pointert megadni
\begin{minted}{cpp}
struct p3d_aggr
{
    p2d *p2; // aggregáció: külső adatra hivatkozás
    double z;
};
\end{minted}
    \item példányosítás és használat:
\begin{minted}{cpp}
p3d_aggr p3a;
p2d p2p; // önálló 2d-s pont
p2p.x = 3;
p2p.y = 4; // meglévő pont címe kell!
p3a.p2 = &p2p; // így kap értéket a pointer.
p3a.z = 5;
\end{minted}
    \item ha p3a dinamikus példány lett volna, akkor kitörlése után p2p még létezne
    \item p3a-ban a p2.x és p2.y változtatása p2p-t is változtatja
\end{itemize}

\noindent \textbf{Többszörös öröklődés:}
\begin{itemize}
    \item multiple iheritance
    \item öröklődés típusmódosítói:
    \begin{itemize}
        \item public öröklődés:
        \begin{itemize}
            \item public $\rightarrow$ public
            \item protected $\rightarrow$ protected
            \item private $\rightarrow$ nem elérhető
        \end{itemize}
        \item protected/private öröklődés
        \begin{itemize}
            \item public $\rightarrow$ protected/private
            \item protected $\rightarrow$ protected/private
            \item private $\rightarrow$ nem elérhető
        \end{itemize}
        \item ha nem írjuk ki, akkor az öröklődés típusa private lesz
    \end{itemize}
    \item ha a leszármazott osztály másképp viselkedik, mint az ős: polimorfizmus
    \item egy leszármazottnak több őse is lehet:
\begin{minted}{cpp}
class e : a, d
{
};
\end{minted}
    \item c++ -ban a jele a vessző
    \item ha módosító van, mindkét ős elé ki kell írni
    \item ha az ősökben azonos nevű tagok szerepelnek, akkor a leszármazottban a fordító nem tudja, melyikről van szó
    \item ilyenkor a hatókör operátor segít \texttt{::}
    \item legyen az örökösnek is ugyanolyan nevű adattagja:
\begin{minted}{cpp}
class a
{ public: int i; };

class b
{ public: int i; };

class c : public a, public b
{ public: int i; // ez kicsit túlzó hülyeség };

cOsztalyuDuplanOroklodottPeldany.a::i = 1;
cOsztalyuDuplanOroklodottPeldany.b::i = 2;
cOsztalyuDuplanOroklodottPeldany.i = 3;
\end{minted}
\end{itemize}

% [PLACEHOLDER FOR MULTIPLE INHERITANCE DIAGRAM]