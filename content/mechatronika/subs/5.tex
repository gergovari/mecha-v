\subsection{Írja fel a diszkrét rendszerek be-kimeneti modellezését reprezentáló ARMA-alakját!}

\noindent \textbf{ARMA-alak:}
\begin{itemize}
    \item diszkrét idejű rendszer:
    \begin{itemize}
        \item $u(t)$ és $y(t)$ csak diszkrét $t = T_k, k \in \mathbb{N}, t \in \{..., T_{-k}, ..., T_{-1}, T_0, T_1, ..., T_k, ...\}$ időpontok sorozatában van értelmezve, ahol: $T_{k-1} < T_k < T_{k+1}$
        \item általában $T_k = k \cdot T_s$, ahol $T_s$ a mintavételezési idő
        \item $u[k] := u[T_k]$
        \item $y[k] := y[T_k]$
    \end{itemize}
    \item AutoRegresszív Mozgó Átlag
    \item AR – az $y[k]$ kimenő jel korábbi értékei hogyan hatnak vissza a kimenő jel aktuális értékeire
    \item MA – az $u[k]$ bemenő jel korábbi értékei (mozgó átlaga) milyen hatással bírnak az aktuális kimenetre
    \item mi a bemenő és kimenő jel összefüggésének felírására használjuk
    \item előnyös, mert közvetlenül látszik a memória jelleg, mely léptető (shift) memóriával valósítható meg
    \item általános alak:
    $$ \sum_{i=0}^{n} a_{di} y[k-i] = \sum_{i=0}^{r} b_{di} u[k-i] $$
    \item ezt átrendezve a kimenet új értékének számítása:
    $$ y[k] = \sum_{i=0}^{r} b_{di} u[k-i] - \sum_{i=1}^{n} a_{di} y[k-i] \text{, ahol } a_{d0} = 1 \text{: az } y[k] \text{ együtthatója} $$
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[auto, >=latex, thick]
        % Define styles
        \tikzstyle{block} = [draw, rectangle, minimum height=1.5em, minimum width=1.5em]
        \tikzstyle{sum} = [draw, rectangle, minimum height=2em, minimum width=1.5em]
        \tikzstyle{container} = [draw, rectangle, inner sep=0.3cm]

        % Input
        \node [coordinate] (input) {};
        
        % Split point for u[k]
        \node [coordinate, right=2cm of input] (split_u) {};
        
        % b_d0 block (top)
        \node [block, right=1.5cm of split_u] (bd0) {$b_{d0}$};
        
        % Shift Register U (box with content)
        \node [below=1cm of split_u, align=left] (shiftU_content) {
            $u[k-1]$ \\[0.3cm]
            $u[k-2]$ \\[0.3cm]
            $\vdots$ \\[0.3cm]
            $u[k-r]$
        };
        \node [container, fit=(shiftU_content)] (shiftU) {};
        
        % Arrows into Shift Register U
        \draw [->] (split_u) -- (shiftU.north);
        
        % Coefficient blocks b_d
        % We manually position them relative to the lines in the shift register for alignment
        % It's easier to define coordinates relative to shiftU_content
        \node [block, right=1.5cm of shiftU_content.north east, anchor=west, yshift=-0.3cm] (bd1) {$b_{d1}$};
        \node [block, right=1.5cm of shiftU_content.east, anchor=west, yshift=0.3cm] (bd2) {$b_{d2}$}; % Approx
        \node [block, right=1.5cm of shiftU_content.south east, anchor=west, yshift=0.3cm] (bdr) {$b_{dr}$};
        
        % Connect Shift U to b blocks
        % Using specific anchors on the content node if possible, or manual offsets
        \draw [->] (shiftU.north east) ++(0,-0.6cm) -- (bd1.west); 
        \draw [->] (shiftU.north east) ++(0,-1.4cm) -- (bd2.west);
        \draw [->] (shiftU.south east) ++(0,0.6cm) -- (bdr.west);

        % Sum MA
        \node [sum, right=1.5cm of bd2] (sumMA) {$\Sigma$};
        \node [above=0.1cm of sumMA] {összegző};
        
        \draw [->] (bd0) -| (sumMA.north);
        \draw [->] (bd1) -- (sumMA.160);
        \draw [->] (bd2) -- (sumMA.180);
        \draw [->] (bdr) -- (sumMA.230);
        
        % Global Input Line
        \draw [->] (input) -- node [above] {$u[k]$} (split_u) -- (bd0);

        % Final Sum
        \node [sum, below right=1cm and 1cm of sumMA] (sumFinal) {$\Sigma$};
        \draw [->] (sumMA) -| (sumFinal.130);
        
        % Output
        \node [coordinate, right=2cm of sumFinal] (output) {};
        \draw [->] (sumFinal) -- node [above] {$y[k]$} (output);
        
        % Feedback path point
        \node [coordinate, right=0.5cm of sumFinal] (split_y) {};
        
        % Shift Register Y (bottom)
        \node [below=4cm of shiftU_content, align=left] (shiftY_content) {
            $y[k-1]$ \\[0.3cm]
            $y[k-2]$ \\[0.3cm]
            $\vdots$ \\[0.3cm]
            $y[k-n]$
        };
        \node [container, fit=(shiftY_content)] (shiftY) {};
        
        % Feedback arrow
        \draw [->] (split_y) |- (shiftY.north);
        
        % Coefficient blocks a_d
        \node [block, right=1.5cm of shiftY_content.north east, anchor=west, yshift=-0.3cm] (ad1) {$a_{d1}$};
        \node [block, right=1.5cm of shiftY_content.east, anchor=west, yshift=0.3cm] (ad2) {$a_{d2}$};
        \node [block, right=1.5cm of shiftY_content.south east, anchor=west, yshift=0.3cm] (adn) {$a_{dn}$};
        
        % Connect Shift Y to a blocks
        \draw [->] (shiftY.north east) ++(0,-0.6cm) -- (ad1.west);
        \draw [->] (shiftY.north east) ++(0,-1.4cm) -- (ad2.west);
        \draw [->] (shiftY.south east) ++(0,0.6cm) -- (adn.west);
        
        % Sum AR (negative)
        \node [sum, right=1.5cm of ad2] (sumAR) {$-\Sigma$};
        \node [below=0.1cm of sumAR] {összegző};
        
        \draw [->] (ad1) -- (sumAR.160);
        \draw [->] (ad2) -- (sumAR.180);
        \draw [->] (adn) -- (sumAR.230);
        
        % Connect Sum AR to Final Sum
        \draw [->] (sumAR) -| (sumFinal.230);
        
        % Labels
        \node [right=0.5cm of bd0] {MA alrendszer};
        \node [right=0.5cm of adn] {AR alrendszer};
        \node [below=0.1cm of shiftY] {léptető memória};

        % Include library for fit if not already loaded (usually useful, but standard node works too)
        % Using simple rectangle draw instead of fit library if not sure, but 'fit' is standard TikZ
    \end{tikzpicture}
\end{figure}